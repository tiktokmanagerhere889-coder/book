"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7019],{8453(n,i,e){e.d(i,{R:()=>r,x:()=>t});var s=e(6540);const l={},o=s.createContext(l);function r(n){const i=s.useContext(o);return s.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function t(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:r(n.components),s.createElement(o.Provider,{value:i},n.children)}},9864(n,i,e){e.r(i),e.d(i,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"modules/ros2-humanoid-control/chapter-3-urdf-modeling","title":"Chapter 3: Humanoid Modeling with URDF","description":"Understanding Unified Robot Description Format and its role in ROS 2 and simulation","source":"@site/docs/modules/ros2-humanoid-control/chapter-3-urdf-modeling.md","sourceDirName":"modules/ros2-humanoid-control","slug":"/modules/ros2-humanoid-control/chapter-3-urdf-modeling","permalink":"/book/docs/modules/ros2-humanoid-control/chapter-3-urdf-modeling","draft":false,"unlisted":false,"editUrl":"https://github.com/hassan/book/tree/master/docs/docs/modules/ros2-humanoid-control/chapter-3-urdf-modeling.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Chapter 3: Humanoid Modeling with URDF","description":"Understanding Unified Robot Description Format and its role in ROS 2 and simulation"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Python Agents with rclpy","permalink":"/book/docs/modules/ros2-humanoid-control/chapter-2-python-agents-rclpy"},"next":{"title":"Digital Twin Simulation: Gazebo & Unity","permalink":"/book/docs/modules/digital-twin-simulation/"}}');var l=e(4848),o=e(8453);const r={sidebar_position:4,title:"Chapter 3: Humanoid Modeling with URDF",description:"Understanding Unified Robot Description Format and its role in ROS 2 and simulation"},t="Chapter 3: Humanoid Modeling with URDF",a={},d=[{value:"Introduction to URDF",id:"introduction-to-urdf",level:2},{value:"The Purpose of URDF",id:"the-purpose-of-urdf",level:2},{value:"Define Physical Structure",id:"define-physical-structure",level:3},{value:"Enable Simulation",id:"enable-simulation",level:3},{value:"Support Advanced Algorithms",id:"support-advanced-algorithms",level:3},{value:"Links, Joints, and Kinematic Chains",id:"links-joints-and-kinematic-chains",level:2},{value:"Links",id:"links",level:3},{value:"Joints",id:"joints",level:3},{value:"Kinematic Chains",id:"kinematic-chains",level:3},{value:"URDF Structure for Humanoid Robots",id:"urdf-structure-for-humanoid-robots",level:2},{value:"Torso and Head",id:"torso-and-head",level:3},{value:"Arms",id:"arms",level:3},{value:"Legs",id:"legs",level:3},{value:"URDF&#39;s Role in ROS 2 and Simulation",id:"urdfs-role-in-ros-2-and-simulation",level:2},{value:"ROS 2 Integration",id:"ros-2-integration",level:3},{value:"Robot State Publisher",id:"robot-state-publisher",level:4},{value:"Visualization",id:"visualization",level:4},{value:"Simulation Environments",id:"simulation-environments",level:3},{value:"Gazebo/Harmonic",id:"gazeboharmonic",level:4},{value:"Ignition Gazebo",id:"ignition-gazebo",level:4},{value:"Webots",id:"webots",level:4},{value:"Creating and Validating URDF Models",id:"creating-and-validating-urdf-models",level:2},{value:"Best Practices",id:"best-practices",level:3},{value:"Validation Tools",id:"validation-tools",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:3},{value:"URDF Extensions and Alternatives",id:"urdf-extensions-and-alternatives",level:2},{value:"XACRO",id:"xacro",level:3},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:3},{value:"Practical Applications",id:"practical-applications",level:2},{value:"Motion Planning",id:"motion-planning",level:3},{value:"Control Systems",id:"control-systems",level:3},{value:"Perception Systems",id:"perception-systems",level:3},{value:"Summary",id:"summary",level:2},{value:"Learning Objectives Review",id:"learning-objectives-review",level:2},{value:"Previous and Next Steps",id:"previous-and-next-steps",level:2}];function c(n){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"chapter-3-humanoid-modeling-with-urdf",children:"Chapter 3: Humanoid Modeling with URDF"})}),"\n",(0,l.jsx)(i.h2,{id:"introduction-to-urdf",children:"Introduction to URDF"}),"\n",(0,l.jsx)(i.p,{children:"URDF (Unified Robot Description Format) is an XML-based format used to describe robot models in ROS. It defines the physical and visual properties of a robot, including its links, joints, inertial properties, visual meshes, and collision geometries."}),"\n",(0,l.jsx)(i.p,{children:"URDF plays a crucial role in ROS 2 by enabling:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Robot visualization in RViz"}),"\n",(0,l.jsx)(i.li,{children:"Physics simulation in Gazebo and other simulators"}),"\n",(0,l.jsx)(i.li,{children:"Kinematic analysis and inverse kinematics"}),"\n",(0,l.jsx)(i.li,{children:"Motion planning algorithms"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"the-purpose-of-urdf",children:"The Purpose of URDF"}),"\n",(0,l.jsx)(i.p,{children:"URDF serves as the standard way to represent robot models in the ROS ecosystem. It allows developers to:"}),"\n",(0,l.jsx)(i.h3,{id:"define-physical-structure",children:"Define Physical Structure"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Specify the geometric shape and size of robot parts"}),"\n",(0,l.jsx)(i.li,{children:"Describe how different parts are connected via joints"}),"\n",(0,l.jsx)(i.li,{children:"Define mass properties and inertial characteristics"}),"\n",(0,l.jsx)(i.li,{children:"Set visual appearance and materials"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"enable-simulation",children:"Enable Simulation"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Create accurate physics models for robot simulation"}),"\n",(0,l.jsx)(i.li,{children:"Test control algorithms in a virtual environment before deployment"}),"\n",(0,l.jsx)(i.li,{children:"Validate robot designs without building physical prototypes"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"support-advanced-algorithms",children:"Support Advanced Algorithms"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Provide kinematic models for motion planning"}),"\n",(0,l.jsx)(i.li,{children:"Enable collision detection and avoidance"}),"\n",(0,l.jsx)(i.li,{children:"Facilitate robot calibration and state estimation"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"links-joints-and-kinematic-chains",children:"Links, Joints, and Kinematic Chains"}),"\n",(0,l.jsx)(i.h3,{id:"links",children:"Links"}),"\n",(0,l.jsxs)(i.p,{children:["A ",(0,l.jsx)(i.strong,{children:"link"})," in URDF represents a rigid body part of the robot. Each link can have:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Visual properties"}),": How the link appears in visualization"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Collision properties"}),": Geometry used for collision detection"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Inertial properties"}),": Mass, center of mass, and inertia tensor"]}),"\n"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-xml",children:'<link name="base_link">\n  <visual>\n    <geometry>\n      <cylinder length="0.6" radius="0.2"/>\n    </geometry>\n    <material name="blue">\n      <color rgba="0 0 0.8 1"/>\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder length="0.6" radius="0.2"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="10"/>\n    <origin xyz="0 0 0"/>\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>\n  </inertial>\n</link>\n'})}),"\n",(0,l.jsx)(i.h3,{id:"joints",children:"Joints"}),"\n",(0,l.jsxs)(i.p,{children:["A ",(0,l.jsx)(i.strong,{children:"joint"})," connects two links and defines their relative motion. URDF supports several joint types:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Fixed"}),": No relative motion between links"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Revolute"}),": Rotational motion around a single axis (with limits)"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Continuous"}),": Unlimited rotational motion around a single axis"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Prismatic"}),": Linear motion along a single axis (with limits)"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Floating"}),": 6 degrees of freedom (6DOF) motion"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Planar"}),": Motion on a plane"]}),"\n"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-xml",children:'<joint name="base_to_wheel" type="continuous">\n  <parent link="base_link"/>\n  <child link="wheel_link"/>\n  <origin xyz="0.2 0 0" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n</joint>\n'})}),"\n",(0,l.jsx)(i.h3,{id:"kinematic-chains",children:"Kinematic Chains"}),"\n",(0,l.jsxs)(i.p,{children:["A ",(0,l.jsx)(i.strong,{children:"kinematic chain"})," is a series of links connected by joints that form a path from a base link to an end effector. In humanoid robots, examples include:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Arm chain"}),": From torso to hand"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Leg chain"}),": From hip to foot"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Head chain"}),": From neck to head"]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Kinematic chains are essential for:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Forward kinematics (calculating end effector position from joint angles)"}),"\n",(0,l.jsx)(i.li,{children:"Inverse kinematics (calculating joint angles to achieve desired end effector position)"}),"\n",(0,l.jsx)(i.li,{children:"Motion planning and trajectory generation"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"urdf-structure-for-humanoid-robots",children:"URDF Structure for Humanoid Robots"}),"\n",(0,l.jsx)(i.p,{children:"Humanoid robots have complex kinematic structures with multiple limbs. A typical humanoid URDF includes:"}),"\n",(0,l.jsx)(i.h3,{id:"torso-and-head",children:"Torso and Head"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Base link representing the main body"}),"\n",(0,l.jsx)(i.li,{children:"Neck joint for head movement"}),"\n",(0,l.jsx)(i.li,{children:"Head link with sensors (cameras, IMUs)"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"arms",children:"Arms"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Shoulder joints for upper arm movement"}),"\n",(0,l.jsx)(i.li,{children:"Elbow joints for lower arm movement"}),"\n",(0,l.jsx)(i.li,{children:"Wrist joints for hand positioning"}),"\n",(0,l.jsx)(i.li,{children:"Hand/End effector definitions"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"legs",children:"Legs"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Hip joints for upper leg movement"}),"\n",(0,l.jsx)(i.li,{children:"Knee joints for lower leg movement"}),"\n",(0,l.jsx)(i.li,{children:"Ankle joints for foot positioning"}),"\n",(0,l.jsx)(i.li,{children:"Foot links for ground contact"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Here's a simplified example of a humanoid arm structure:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-xml",children:'\x3c!-- Left Arm --\x3e\n<joint name="left_shoulder_pitch" type="revolute">\n  <parent link="torso_link"/>\n  <child link="left_upper_arm_link"/>\n  <origin xyz="0.2 0.15 0.1" rpy="0 0 0"/>\n  <axis xyz="1 0 0"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n</joint>\n\n<link name="left_upper_arm_link">\n  <visual>\n    <geometry>\n      <capsule length="0.3" radius="0.05"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <capsule length="0.3" radius="0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="2"/>\n    <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\n  </inertial>\n</link>\n\n<joint name="left_elbow_yaw" type="revolute">\n  <parent link="left_upper_arm_link"/>\n  <child link="left_lower_arm_link"/>\n  <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-2.0" upper="2.0" effort="100" velocity="1"/>\n</joint>\n\n<link name="left_lower_arm_link">\n  <visual>\n    <geometry>\n      <capsule length="0.25" radius="0.04"/>\n    </geometry>\n  </visual>\n  <collision>\n    <geometry>\n      <capsule length="0.25" radius="0.04"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="1.5"/>\n    <inertia ixx="0.05" ixy="0" ixz="0" iyy="0.05" iyz="0" izz="0.05"/>\n  </inertial>\n</link>\n'})}),"\n",(0,l.jsx)(i.h2,{id:"urdfs-role-in-ros-2-and-simulation",children:"URDF's Role in ROS 2 and Simulation"}),"\n",(0,l.jsx)(i.h3,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,l.jsx)(i.p,{children:"URDF integrates with ROS 2 through several mechanisms:"}),"\n",(0,l.jsx)(i.h4,{id:"robot-state-publisher",children:"Robot State Publisher"}),"\n",(0,l.jsxs)(i.p,{children:["The ",(0,l.jsx)(i.code,{children:"robot_state_publisher"})," package takes a URDF and joint positions to publish the resulting transforms to the TF2 tree, allowing other ROS nodes to understand the spatial relationship between different parts of the robot."]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom urdf_parser_py.urdf import URDF\nfrom pykdl_utils.kdl_parser import kdl_tree_from_urdf_model\n\nclass RobotStateNode(Node):\n    def __init__(self):\n        super().__init__('robot_state_node')\n\n        # Load URDF from parameter or file\n        robot_description = self.get_parameter_or(\n            'robot_description',\n            '/path/to/robot.urdf'\n        ).value\n\n        # Parse URDF\n        robot = URDF.from_xml_string(robot_description)\n\n        # Use URDF for kinematic calculations\n        tree = kdl_tree_from_urdf_model(robot)\n"})}),"\n",(0,l.jsx)(i.h4,{id:"visualization",children:"Visualization"}),"\n",(0,l.jsx)(i.p,{children:"URDF models are visualized in RViz2 using the RobotModel display type, allowing developers to see how their robot will appear in the real world or simulation."}),"\n",(0,l.jsx)(i.h3,{id:"simulation-environments",children:"Simulation Environments"}),"\n",(0,l.jsx)(i.p,{children:"URDF models are used in various simulation environments:"}),"\n",(0,l.jsx)(i.h4,{id:"gazeboharmonic",children:"Gazebo/Harmonic"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Physics simulation with realistic dynamics"}),"\n",(0,l.jsx)(i.li,{children:"Sensor simulation (cameras, LiDAR, IMUs)"}),"\n",(0,l.jsx)(i.li,{children:"Environment interaction"}),"\n"]}),"\n",(0,l.jsx)(i.h4,{id:"ignition-gazebo",children:"Ignition Gazebo"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Modern simulation engine"}),"\n",(0,l.jsx)(i.li,{children:"High-fidelity physics and rendering"}),"\n",(0,l.jsx)(i.li,{children:"Realistic sensor models"}),"\n"]}),"\n",(0,l.jsx)(i.h4,{id:"webots",children:"Webots"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Web-based simulation platform"}),"\n",(0,l.jsx)(i.li,{children:"Multi-robot simulation capabilities"}),"\n",(0,l.jsx)(i.li,{children:"Realistic physics and sensors"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"creating-and-validating-urdf-models",children:"Creating and Validating URDF Models"}),"\n",(0,l.jsx)(i.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsx)(i.p,{children:"When creating URDF models for humanoid robots:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Start Simple"}),": Begin with a basic kinematic model and gradually add complexity"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Use Standard Formats"}),": Follow URDF conventions for consistency"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Include Proper Inertias"}),": Accurate mass properties are crucial for simulation"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Validate Joint Limits"}),": Ensure joint ranges match physical capabilities"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Test Incrementally"}),": Add one limb at a time and test each addition"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"validation-tools",children:"Validation Tools"}),"\n",(0,l.jsx)(i.p,{children:"Several tools help validate URDF models:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"check_urdf"}),": Checks syntax and basic validity"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"urdf_tutorial"}),": Provides examples and validation procedures"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"RViz"}),": Visual inspection of the robot model"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"TF2 tools"}),": Check transform relationships"]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Example validation command:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-bash",children:"check_urdf /path/to/robot.urdf\n"})}),"\n",(0,l.jsx)(i.h3,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Incorrect Origins"}),": Joint origins that don't match physical mounting points"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Missing Inertias"}),": Links without proper mass/inertia properties"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Invalid Joint Limits"}),": Limits that exceed physical capabilities"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"Non-unique Names"}),": Duplicate link or joint names"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"urdf-extensions-and-alternatives",children:"URDF Extensions and Alternatives"}),"\n",(0,l.jsx)(i.p,{children:"While URDF is the standard in ROS, there are extensions and alternatives:"}),"\n",(0,l.jsx)(i.h3,{id:"xacro",children:"XACRO"}),"\n",(0,l.jsx)(i.p,{children:"XACRO (XML Macros) extends URDF with:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Parameter substitution"}),"\n",(0,l.jsx)(i.li,{children:"Mathematical expressions"}),"\n",(0,l.jsx)(i.li,{children:"Macro definitions"}),"\n",(0,l.jsx)(i.li,{children:"File inclusion"}),"\n"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_robot">\n\n<xacro:property name="M_PI" value="3.1415926535897931" />\n<xacro:property name="arm_length" value="0.3" />\n\n<xacro:macro name="simple_arm" params="prefix parent_link">\n  <joint name="${prefix}_shoulder_joint" type="revolute">\n    <parent link="${parent_link}"/>\n    <child link="${prefix}_upper_arm_link"/>\n    <origin xyz="0 0.1 0" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="${-M_PI/2}" upper="${M_PI/2}" effort="100" velocity="1"/>\n  </joint>\n\n  <link name="${prefix}_upper_arm_link">\n    <visual>\n      <geometry>\n        <capsule length="${arm_length}" radius="0.05"/>\n      </geometry>\n    </visual>\n  </link>\n</xacro:macro>\n\n\x3c!-- Use the macro --\x3e\n<xacro:simple_arm prefix="left" parent_link="torso_link"/>\n\n</robot>\n'})}),"\n",(0,l.jsx)(i.h3,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,l.jsx)(i.p,{children:"Used primarily in Gazebo/Ignition with more advanced simulation features."}),"\n",(0,l.jsx)(i.h2,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,l.jsx)(i.h3,{id:"motion-planning",children:"Motion Planning"}),"\n",(0,l.jsx)(i.p,{children:"URDF models enable motion planning algorithms to:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Calculate inverse kinematics solutions"}),"\n",(0,l.jsx)(i.li,{children:"Plan collision-free trajectories"}),"\n",(0,l.jsx)(i.li,{children:"Optimize joint configurations"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"control-systems",children:"Control Systems"}),"\n",(0,l.jsx)(i.p,{children:"Controllers use URDF models to:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Implement computed torque control"}),"\n",(0,l.jsx)(i.li,{children:"Calculate dynamic compensation"}),"\n",(0,l.jsx)(i.li,{children:"Estimate robot state"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"perception-systems",children:"Perception Systems"}),"\n",(0,l.jsx)(i.p,{children:"URDF models help perception systems:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Register sensor data to robot frame"}),"\n",(0,l.jsx)(i.li,{children:"Segment robot parts from environment"}),"\n",(0,l.jsx)(i.li,{children:"Track robot pose and configuration"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,l.jsx)(i.p,{children:"In this chapter, we've covered:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"The purpose of URDF in describing robot models"}),"\n",(0,l.jsx)(i.li,{children:"Links, joints, and kinematic chains in robot structure"}),"\n",(0,l.jsx)(i.li,{children:"URDF's role in ROS 2 and simulation environments"}),"\n",(0,l.jsx)(i.li,{children:"Best practices for creating and validating URDF models"}),"\n",(0,l.jsx)(i.li,{children:"Extensions like XACRO for more complex descriptions"}),"\n",(0,l.jsx)(i.li,{children:"Practical applications in motion planning and control"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"URDF is fundamental to robotics development in ROS, especially for complex humanoid robots where accurate modeling of kinematic chains is essential for successful operation."}),"\n",(0,l.jsx)(i.h2,{id:"learning-objectives-review",children:"Learning Objectives Review"}),"\n",(0,l.jsx)(i.p,{children:"After completing this chapter, you should be able to:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Explain the purpose of URDF in robot modeling"}),"\n",(0,l.jsx)(i.li,{children:"Describe links, joints, and kinematic chains concepts"}),"\n",(0,l.jsx)(i.li,{children:"Understand URDF's role in ROS 2 and simulation"}),"\n",(0,l.jsx)(i.li,{children:"Create basic URDF models for robot components"}),"\n",(0,l.jsx)(i.li,{children:"Identify best practices for URDF development"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"previous-and-next-steps",children:"Previous and Next Steps"}),"\n",(0,l.jsxs)(i.p,{children:["Previous: ",(0,l.jsx)(i.a,{href:"/book/docs/modules/ros2-humanoid-control/chapter-2-python-agents-rclpy",children:"Chapter 2: Python Agents with rclpy"})]}),"\n",(0,l.jsxs)(i.p,{children:["Return to ",(0,l.jsx)(i.a,{href:"/book/docs/modules/ros2-humanoid-control/",children:"Module Home"})," or explore additional ROS 2 topics."]})]})}function h(n={}){const{wrapper:i}={...(0,o.R)(),...n.components};return i?(0,l.jsx)(i,{...n,children:(0,l.jsx)(c,{...n})}):c(n)}}}]);